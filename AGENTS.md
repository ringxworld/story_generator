# AGENTS.md

Repository operating rules for coding agents.

## 0. Prime Directive

- You may generate code quickly.
- You may not change architecture without explicit approval.
- If a requested change violates repository contracts, stop and ask for clarification.
- Prefer correctness and boundary integrity over speed.

## 1. Required Repository Contracts

These artifacts must remain present:

- `LICENSE`
- `CONTRIBUTING.md`
- `SECURITY.md`
- `CODEOWNERS`
- `docs/architecture.md`
- `docs/adr/`

If a change introduces new public behavior or a new dependency, add an ADR.

## 2. Module Ownership and Boundaries

Python ownership model:

- `src/story_gen/api/` -> public API layer
- `src/story_gen/core/` -> internal logic
- `src/story_gen/adapters/` -> side effects / IO
- `src/story_gen/native/` -> native binding boundary
- `src/story_gen/cli/` -> argparse command entrypoints

Import rules:

- `api` may import `core`, `adapters`, `native`
- `core` must not import `api`, `adapters`, `native`
- `adapters` must not be imported by `core`
- only `native` may import compiled extension modules

## 3. Python / C++ Boundary Rules

- C++ source: `cpp/`
- Public C++ headers: `cpp/include/`
- Binding code: `bindings/` or `src/story_gen/native/`
- C++ must not include Python headers outside binding code
- Python must not expose raw-pointer ownership semantics

## 4. Quality and Enforcement

Expected checks:

- `uv lock --check`
- `uv run python tools/check_imports.py`
- `uv run ruff check .`
- `uv run ruff format --check .`
- `uv run mypy`
- `uv run pytest`
- `uv run mkdocs build --strict`

Do not bypass pre-commit or CI.
Do not remove tests to satisfy gates. Add or adjust tests to validate both
working paths and failure paths of the behavior under test.

## 4.1 Mandatory Adversarial Self-Review

For every implementation task, run an explicit adversarial pass before finalizing:

- Assume the current approach is wrong until falsified.
- Try to break it with realistic edge cases, malformed inputs, and boundary values.
- Check for regressions in contracts, schema compatibility, auth/permissions, and data integrity.
- Check for silent failure paths, weak error handling, and misleading success states.

This step is required before concluding work, opening a PR, or requesting merge.

## 4.2 Mandatory PR Bug Sweep

For every pull request, perform a bug-focused review of all changed files:

- Inspect each changed file directly (do not sample a subset).
- Record findings by severity; if no findings exist, state that explicitly.
- Always call out residual risk and test gaps, even when findings are empty.
- For every confirmed bug, add a regression test before merge.

## 5. Entropy Prevention

- No `utils` module names.
- No `TODO` without issue reference (example: `TODO(#123): ...`).
- No new public API without docs and tests.
- Feature flags require explicit removal plan.

## 6. ADR Discipline

Before non-trivial implementation, add/update ADR with:

- Problem
- Non-goals
- Public API
- Invariants
- Test plan

## 7. Completion Rule

After each completed prompt:

1. implement
2. validate
3. commit
4. push feature branch
5. open PR to `develop`
6. merge via PR after required checks pass

## 7.1 Branch and PR Discipline

This repository is PR-first and feature-branch-only for agent work:

- Always branch from latest `origin/develop` before making changes.
- Never commit directly to `develop` or `main`.
- If work is started on `main`, immediately move the changes to a feature branch from `develop`.
- Keep changes isolated to one human-readable feature branch per task.
- After pushing, open/update a PR to `develop` and link the relevant issue URL.
- Do not close implementation issues until the PR is merged.

## 7.2 Branch and Commit Naming Style

Keep branch names and commit messages readable and human, not autogenerated-sounding:

- Prefer short natural phrasing over heavy prefixes and formal templates.
- Avoid AI-sounding wording like "implement comprehensive", "leverage", "orchestrate", "robust", "end-to-end" unless truly required.
- Use lowercase, concise branch names that describe the actual change.
- Keep commit subjects plain and specific, as if written quickly by a teammate.
- If a change is exploratory or partial, say that directly instead of implying finality.

Examples:

- Branch: `fix/mining-click-order`, `oyster-vision-tuning`, `ros2-bringup-make-targets`
- Commit: `fix mining click ordering in overlap case`
- Commit: `wire ros2 stack targets into makefile`

## 8. Human-Facing Wording for Issues and PRs

When writing issue or PR text:

- Use human, specific language over boilerplate.
- Prefer concrete sentences about intent and impact.
- Avoid templated phrases like "This change does X" when a more natural sentence works.
- Link issues with full URLs, not just `#123`.
- State tradeoffs and test coverage explicitly, without hedging.

## 9. Human-Facing PR Reviews

When commenting or reviewing pull requests:

- Use normal paragraph spacing and complete sentences.
- Lead with the most important finding, then explain why it matters.
- Avoid robotic checklists unless the author asked for one.
- Call out missing tests and edge cases in plain language.

## 10. Human PR Status Comments

When posting status comments on PRs:

- Keep comments short (3 to 6 lines).
- Use this order: `current state`, `why`, `next step`.
- Name the branch or PR causing the blocker, not vague "baseline" language.
- Prefer one clear sentence per point instead of long chained clauses.
- If the result is uncertain, say what needs to happen to confirm it.

Example tone:

- Avoid: "CI failures on this PR are inherited from current develop baseline..."
- Prefer: "This PR fails for the same reason `#1` is failing in `develop`. After `#1` merges, rebase this branch and rerun checks."
## 11. Project Board Hygiene

Treat the GitHub Projects page as a first-class planning surface:

- Keep project names, view names, and field names human-readable.
- Keep issue titles concise so board scans are clear.
- Keep `Status`, `Track`, and `Priority Band` up to date as work moves.
- Avoid placeholder names (for example: `View 1`) once a board is active.
- Keep Project `#2` synchronized with active roadmap issues and open PRs via `make project-sync` (or the `project-board-sync` workflow).

## 12. Issue Close-Out Summaries

When closing an issue, always add a structured summary comment first, then close:

- Use `.github/ISSUE_CLOSE_SUMMARY_TEMPLATE.md` as the baseline.
- Required headings: `Work Summary`, `Objective`, `Root Cause`, `Approach`, `Implementation Details`, `Validation`, and `Ownership / Follow-ups`.
- Include concrete artifacts (PR URLs, commit SHAs, tests executed).
- Use `make issue-close ISSUE_NUMBER=<n> ISSUE_SUMMARY_FILE=<path>` so closure and summary stay paired.

## 13. Documentation Ownership Split

Use one clear source of truth per documentation type:

- Repo docs (`docs/`, API contracts, architecture, ADRs, runbooks tied to code) hold versioned technical truth.
- Wiki holds collaborative/project-operations material (roadmap context, planning notes, meeting outcomes, onboarding checklists, weekly change notes).
- GitHub Pages holds public product/demo narrative and a static docs snapshot at `/docs/`.

Rule of thumb:

- If content must stay correct for a specific commit/release, keep it in repo docs.
- If content is operational/collaborative and can evolve independently, keep it in wiki.

Guardrail:

- Avoid duplicate docs across repo and wiki; keep one source and link from the other.
- For API/code documentation, repo docs are always the source of truth.

## 14. External Issue Intake and Priority Gate

Treat external issues as intake signals, not automatic roadmap commitments:

- External issues must be triaged before being added to roadmap/project execution lanes.
- Evaluate signal quality first: reproducibility, user impact, and acceptance criteria.
- Label external intake explicitly (`external`, `needs-triage`) and only assign priority after review.
- If details are insufficient, require clarification (`needs-info`) before implementation planning.
- Internal execution templates (for example `[task]`) are maintainer-only; external task-form submissions are closed as `not planned`.

## 15. Adversarial Issue-Closure Verification

Treat closed issues as untrusted until verified:

- Assume closure summaries can over-promise; verify acceptance criteria against merged artifacts or explicit manual checks.
- Evidence order: merged PRs + tests > merged PRs only > manual platform verification notes.
- If acceptance criteria are not evidenced, do not leave the issue quietly closed.

Decision policy when evidence is insufficient:

- Reopen the issue when core acceptance criteria are still unmet.
- Create a linked follow-up issue when the original outcome is mostly valid but verifiability or hardening is missing.
- Record the verification result in a comment using concrete artifacts (PR URLs, commands run, current state observed).

## 16. Dependabot Handling

Treat Dependabot PRs as first-class maintenance work:

- Always triage Dependabot PRs when they arrive; do not leave them unattended.
- Prefer automated merge for safe semver bumps (patch/minor) after required checks pass.
- Require manual review for major/ambiguous updates before merge.
- If a Dependabot PR fails checks, identify whether the failure is dependency-driven and add/adjust tests to guard the compatibility gap before merge.
